<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memory Mosaic</title>

  <!-- Optional fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500;700&family=Playfair+Display:ital,wght@0,500;1,500&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg: #0f1115;
      --card: rgba(255,255,255,0.06);
      --stroke: rgba(255,255,255,0.10);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --accent: rgba(88, 255, 196, 0.85);

      --paper: rgba(255, 248, 235, 0.97);
      --ink: rgba(25, 18, 12, 0.92);
      --paperStroke: rgba(30, 20, 10, 0.15);

      --shadow: 0 18px 46px rgba(0,0,0,0.45);
      --radius: 18px;
      --gap: 12px;
      --maxWidth: 1320px;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }
    body{
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(88, 255, 196, 0.08), transparent),
        radial-gradient(1000px 600px at 90% 20%, rgba(139, 92, 246, 0.10), transparent),
        var(--bg);
      color: var(--text);
    }

    header{
      position: sticky;
      top: 0;
      z-index: 10;
      padding: 18px 18px 10px;
      border-bottom: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(15,17,21,0.92), rgba(15,17,21,0.72));
    }

    .headerWrap{
      max-width: var(--maxWidth);
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 14px;
      flex-wrap: wrap;
    }

    header h1{ margin: 0; font-size: 20px; letter-spacing: .2px; }
    header p{ margin: 6px 0 0; color: var(--muted); font-size: 13px; }

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    button{
      border: 1px solid var(--stroke);
      background: var(--card);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
      white-space: nowrap;
    }
    button:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.09);
    }

    .searchWrap{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    #searchInput{
      width: min(420px, 70vw);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      outline: none;
    }
    #searchInput:focus{
      border-color: rgba(88,255,196,0.35);
      box-shadow: 0 0 0 2px rgba(88,255,196,0.12);
    }
    .resultCount{ color: var(--muted); font-size: 12px; }

    main{
      max-width: var(--maxWidth);
      margin: 0 auto;
      padding: 16px 18px 26px;
    }

    .layout{
      display: grid;
      grid-template-columns: 1.55fr 0.95fr;
      gap: 14px;
      align-items: start;
    }

    /* Mosaic */
    .mosaic{
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: var(--gap);
    }

    .tile{
      grid-column: span 3;        /* 12 / 3 = 4 tiles per row on desktop */
      aspect-ratio: 1 / 1;
      border-radius: var(--radius);
      overflow: hidden;
      position: relative;
      border: 1px solid var(--stroke);
      box-shadow: 0 10px 28px rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.02);
      cursor: pointer;
      outline: none;
      padding: 0;
    }

    .tile img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display:block;
      transition: transform .25s ease, filter .25s ease;
      filter: saturate(1.05) contrast(1.02);
    }

    .tile:hover img,
    .tile:focus-visible img{
      transform: scale(1.02);
      filter: saturate(1.1) contrast(1.05);
    }

    .tile.is-active{
      border-color: rgba(88,255,196,0.35);
      box-shadow: 0 0 0 2px rgba(88,255,196,0.18), 0 10px 28px rgba(0,0,0,0.28);
    }

    .badge{
      position:absolute;
      left:10px;
      bottom:10px;
      max-width: calc(100% - 20px);
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(10,10,12,0.42);
      backdrop-filter: blur(8px);
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
    }

    .tile:hover .badge,
    .tile:focus-visible .badge{
      opacity: 1;
      transform: translateY(0);
    }

    /* Journal panel */
    aside{ position: sticky; top: 84px; }

    .journal{
      border-radius: 22px;
      border: 1px solid var(--paperStroke);
      background: var(--paper);
      color: var(--ink);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .journalTop{
      padding: 16px 16px 12px;
      border-bottom: 1px dashed rgba(0,0,0,0.16);
      position: relative;
    }

    .journalTop::before,
    .journalBody::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(circle at 20% 30%, rgba(0,0,0,0.04), transparent 55%),
        repeating-linear-gradient(to bottom,
          rgba(0,0,0,0.03),
          rgba(0,0,0,0.03) 1px,
          transparent 1px,
          transparent 22px
        );
      opacity:0.35;
      pointer-events:none;
    }

    .journalTitle{
      position:relative; z-index:1;
      margin:0;
      font-family: "Playfair Display", Georgia, serif;
      font-weight: 500;
      font-size: 20px;
      letter-spacing: .2px;
    }

    .journalMeta{
      position:relative; z-index:1;
      display:flex;
      flex-wrap:wrap;
      gap:8px 10px;
      margin-top:8px;
      color: rgba(25,18,12,0.78);
      font-size:12px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,0.05);
      border: 1px solid rgba(0,0,0,0.08);
      white-space:nowrap;
    }
    .dot{ width:7px; height:7px; border-radius:50%; background: rgba(0,0,0,0.22); }

    .journalBody{
      position:relative;
      padding: 14px 16px 18px;
      max-height: calc(100vh - 170px);
      overflow:auto;
    }

    .journalText{
      position:relative; z-index:1;
      font-family:"Caveat", system-ui, sans-serif;
      font-size:22px;
      line-height:1.18;
      letter-spacing:.2px;
      white-space: pre-wrap; /* preserves multi-paragraph notes */
    }

    .emptyState{
      position:relative; z-index:1;
      margin-top:10px;
      color: rgba(25,18,12,0.70);
      font-size: 13px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .errorBox{
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 100, 100, 0.25);
      background: rgba(255, 90, 90, 0.08);
      color: rgba(255,255,255,0.90);
      margin: 10px 0 0;
      font-size: 13px;
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      aside{ position: relative; top: 0; }
      .journalBody{ max-height: none; }
      .tile{ grid-column: span 4; } /* 3 per row */
    }
    @media (max-width: 560px){
      .tile{ grid-column: span 6; } /* 2 per row */
      button{ flex: 1; }
    }
    @media (max-width: 420px){
      .tile{ grid-column: span 12; } /* 1 per row */
    }

    footer{
      max-width: var(--maxWidth);
      margin: 0 auto;
      padding: 0 18px 26px;
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>

<body>
<header>
  <div class="headerWrap">
    <div>
      <h1>Memory Mosaic</h1>
      <p>Search your memories and click a photo to read its permanent journal entry.</p>
    </div>

    <div class="controls">
      <div class="searchWrap">
        <input id="searchInput" type="search"
               placeholder="Search title, tags, location, filename, or note…"
               autocomplete="off" />
        <button id="clearSearchBtn" type="button">Clear</button>
        <span id="resultCount" class="resultCount"></span>
      </div>

      <button id="shuffleBtn" type="button" title="Shuffles the tile order only (does not change your data)">Shuffle</button>
      <button id="rememberBtn" type="button" aria-pressed="true" title="Remember last opened memory on this device">Remember: ON</button>
    </div>
  </div>
</header>

<main>
  <div id="loadError" class="errorBox" style="display:none;"></div>

  <div class="layout">
    <section aria-label="Photo mosaic">
      <div class="mosaic" id="mosaic"></div>
    </section>

    <aside aria-label="Journal panel">
      <div class="journal" role="region" aria-live="polite">
        <div class="journalTop">
          <h2 class="journalTitle" id="jTitle">Select a photo</h2>
          <div class="emptyState" id="emptyState">
            Tip: Use the search bar to filter. Share a specific memory using a link like <code>#your-id</code>.
          </div>

          <div class="journalMeta" id="jMeta" style="display:none;">
            <span class="pill"><span class="dot"></span><span id="jDate"></span></span>
            <span class="pill"><span class="dot"></span><span id="jLocation"></span></span>
            <span class="pill"><span class="dot"></span><span id="jTags"></span></span>
          </div>
        </div>

        <div class="journalBody">
          <div class="journalText" id="jText"></div>
        </div>
      </div>
    </aside>
  </div>
</main>

<footer>
  Hosted on GitHub Pages. Data is in <code>memories.json</code>.
</footer>

<script>
  // --------- State ----------
  let allMemories = [];
  let visibleMemories = [];
  let rememberLast = true;

  const mosaic = document.getElementById("mosaic");

  const jTitle = document.getElementById("jTitle");
  const jText  = document.getElementById("jText");
  const jDate  = document.getElementById("jDate");
  const jLocation = document.getElementById("jLocation");
  const jTags  = document.getElementById("jTags");
  const jMeta  = document.getElementById("jMeta");
  const emptyState = document.getElementById("emptyState");

  const searchInput = document.getElementById("searchInput");
  const clearSearchBtn = document.getElementById("clearSearchBtn");
  const resultCount = document.getElementById("resultCount");

  const shuffleBtn = document.getElementById("shuffleBtn");
  const rememberBtn = document.getElementById("rememberBtn");

  const loadError = document.getElementById("loadError");

  // --------- Helpers ----------
  const normalize = (s) => (s || "").toString().toLowerCase();
  const formatDate = (iso) => {
    if (!iso) return "—";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return iso;
    return d.toLocaleDateString(undefined, { day:"2-digit", month:"short", year:"numeric" });
  };

  function debounce(fn, ms=120){
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  // Lazy-load images when they enter viewport
  let io;
  function setupIntersectionObserver(){
    if (!("IntersectionObserver" in window)) return;
    io = new IntersectionObserver(entries => {
      for (const e of entries){
        if (e.isIntersecting){
          const img = e.target;
          const src = img.dataset.src;
          if (src){
            img.src = src;
            img.removeAttribute("data-src");
          }
          io.unobserve(img);
        }
      }
    }, { rootMargin: "250px" });
  }

  function matchesQuery(m, q){
    if (!q) return true;
    const hay = [
      m.id, m.title, m.date, m.location, m.file,
      (m.tags || []).join(" "),
      m.note
    ].map(normalize).join("  ");
    return hay.includes(q);
  }

  function setActiveTile(id){
    mosaic.querySelectorAll(".tile").forEach(btn => {
      btn.classList.toggle("is-active", btn.dataset.id === id);
    });
  }

  function openMemoryById(id, {pushHash=true} = {}){
    const m = allMemories.find(x => x.id === id) || visibleMemories.find(x => x.id === id);
    if (!m) return;

    jTitle.textContent = m.title || "Untitled";
    jText.textContent  = m.note || "";

    emptyState.style.display = "none";
    jMeta.style.display = "flex";

    jDate.textContent = formatDate(m.date);
    jLocation.textContent = m.location || "—";
    jTags.textContent = (m.tags && m.tags.length) ? m.tags.join(" • ") : "—";

    setActiveTile(m.id);

    if (pushHash && m.id){
      history.replaceState(null, "", `#${encodeURIComponent(m.id)}`);
    }
    if (rememberLast && m.id){
      localStorage.setItem("mm_last_id", m.id);
    }
  }

  // --------- Render ----------
  function renderMosaic(list){
    mosaic.innerHTML = "";

    const frag = document.createDocumentFragment();

    for (const m of list){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "tile";
      btn.dataset.id = m.id;

      const img = document.createElement("img");
      img.alt = m.title || m.id;

      // Use thumbs for speed (fallback to file if no thumbs)
      // Lazy load: set data-src instead of src initially
      img.dataset.src = m.thumb || m.file;

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.textContent = m.title || m.id;

      btn.appendChild(img);
      btn.appendChild(badge);

      btn.addEventListener("click", () => openMemoryById(m.id, {pushHash:true}));
      btn.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          openMemoryById(m.id, {pushHash:true});
        }
      });

      frag.appendChild(btn);

      if (io) io.observe(img);
    }

    mosaic.appendChild(frag);
  }

  // --------- Search ----------
  function applySearch(){
    const q = normalize(searchInput.value).trim();
    visibleMemories = allMemories.filter(m => matchesQuery(m, q));
    resultCount.textContent = `${visibleMemories.length} / ${allMemories.length}`;

    renderMosaic(visibleMemories);

    // Keep selection if still visible; otherwise open first result
    const currentId = decodeURIComponent((location.hash || "").replace("#",""));
    if (currentId && visibleMemories.some(m => m.id === currentId)){
      openMemoryById(currentId, {pushHash:false});
    } else if (visibleMemories[0]){
      openMemoryById(visibleMemories[0].id, {pushHash:false});
    } else {
      // No results: clear panel
      jTitle.textContent = "No matches";
      jText.textContent = "Try a different keyword.";
      jMeta.style.display = "none";
      emptyState.style.display = "none";
    }
  }

  const applySearchDebounced = debounce(applySearch, 120);

  searchInput.addEventListener("input", applySearchDebounced);
  clearSearchBtn.addEventListener("click", () => {
    searchInput.value = "";
    applySearch();
  });

  // --------- Shuffle (visual only) ----------
  function shuffleArray(a){
    const arr = a.slice();
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  shuffleBtn.addEventListener("click", () => {
    visibleMemories = shuffleArray(visibleMemories);
    renderMosaic(visibleMemories);
    const currentId = decodeURIComponent((location.hash || "").replace("#",""));
    if (currentId) openMemoryById(currentId, {pushHash:false});
  });

  // --------- Remember last toggle ----------
  function updateRememberBtn(){
    rememberBtn.textContent = `Remember: ${rememberLast ? "ON" : "OFF"}`;
    rememberBtn.setAttribute("aria-pressed", String(rememberLast));
  }
  updateRememberBtn();

  rememberBtn.addEventListener("click", () => {
    rememberLast = !rememberLast;
    updateRememberBtn();
    if (!rememberLast) localStorage.removeItem("mm_last_id");
  });

  // --------- Load memories.json ----------
  async function loadMemories(){
    try{
      setupIntersectionObserver();

      const res = await fetch("memories.json", { cache: "no-store" });
      if (!res.ok) throw new Error(`Could not load memories.json (HTTP ${res.status})`);
      const data = await res.json();
      if (!Array.isArray(data)) throw new Error("memories.json must be an array");

      // Basic validation & cleanup
      allMemories = data.map(m => ({
        id: String(m.id || ""),
        file: String(m.file || ""),
        thumb: String(m.thumb || m.file || ""),
        title: String(m.title || m.id || "Untitled"),
        date: String(m.date || ""),
        location: String(m.location || ""),
        tags: Array.isArray(m.tags) ? m.tags.map(String) : [],
        note: String(m.note || "")
      })).filter(m => m.id && m.file);

      visibleMemories = allMemories.slice();
      resultCount.textContent = `${visibleMemories.length} / ${allMemories.length}`;

      renderMosaic(visibleMemories);

      // open by hash OR remembered OR first
      const hashId = decodeURIComponent((location.hash || "").replace("#","")).trim();
      const lastId = rememberLast ? localStorage.getItem("mm_last_id") : null;

      if (hashId && allMemories.some(m => m.id === hashId)){
        openMemoryById(hashId, {pushHash:false});
      } else if (lastId && allMemories.some(m => m.id === lastId)){
        openMemoryById(lastId, {pushHash:false});
      } else if (allMemories[0]){
        openMemoryById(allMemories[0].id, {pushHash:false});
      }
    } catch(err){
      loadError.style.display = "block";
      loadError.textContent =
        "⚠️ Failed to load memories.json. " +
        "Make sure it exists in the repo root and is valid JSON. " +
        "Details: " + err.message;
      console.error(err);
    }
  }

  loadMemories();
</script>
</body>
</html>
